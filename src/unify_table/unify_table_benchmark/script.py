import os
from pathlib import Path
import sys

DATA_PATH = Path("./data")

LENGTH = 1000

TEMPLATE = """
// This file is generated by the benchmark generator.

{functions}

pub fn data() -> FixedArray[((Int, Int, Int), Array[(Int, Int)], Array[Int])] {{
    let result = FixedArray::makei({data_length}, fn(_) {{ ((0, 0, 0), Array::new(), Array::new()) }})
    {data}
    result
}}

pub fn answers() -> FixedArray[Array[Int]] {{
    let result = FixedArray::makei({data_length}, fn(_) {{ Array::new() }})
    {answers}
    result
}}
"""

FUNC_TEMPLATE = """
pub fn get_data_{point}(result: FixedArray[((Int, Int, Int), Array[(Int, Int)], Array[Int])]) -> Unit {{
    {data}
}}
"""

OUTPUT_TEMPLATE = """
pub fn get_answers_{point}(result: FixedArray[Array[Int]]) -> Unit {{
    {data}
}}
"""



def input_reader(path: Path) -> tuple[tuple[int, int, int], list[list[int]], list[int]]:
    """
    Generate the data for the benchmark
    """
    print(f"Reading input from {path}")
    with open(path, "r", encoding="utf-8") as f:
        n, m = map(int, f.readline().split())
        edges = [list(map(int, f.readline().split())) for _ in range(m)]
        k = int(f.readline().strip())
        queries = [int(f.readline().strip()) for _ in range(k)]
        print(f"Read {n} nodes, {m} edges, and {k} queries")
    return (n, m, k), edges, queries


def answer_reader(path: Path) -> list[int]:
    """
    Read the answers from the file
    """
    with open(path, "r", encoding="utf-8") as f:
        return [int(line.strip()) for line in f.readlines()]


def reader(arg: int) -> list[
    tuple[tuple[tuple[int, int, int], list[list[int]], list[int]], list[int]]
]:
    """
    Read the input and answer files
    """
    result = []
    # for i in range(1,2):
    for i in range(arg, arg+1):
        input_path = DATA_PATH / f"{i}.in"
        answer_path = DATA_PATH / f"{i}.out"
        data = input_reader(input_path)
        answers = answer_reader(answer_path)
        result.append((data, answers))
    return result


def generate(
    data: list[
        tuple[tuple[tuple[int, int, int], list[list[int]], list[int]], list[int]]
    ],
) -> str:
    """
    Generate the data for the benchmark
    """
    input = []
    result = []
    functions = []

    ipoint = 0
    opoint = 0

    def pack_input(point: int) -> str:
        return FUNC_TEMPLATE.format(point=point, data="\n    ".join(input))
    
    def pack_output(point: int) -> str:
        return OUTPUT_TEMPLATE.format(point=point, data="\n    ".join(result))


    for idx, (((n, m, k), edges, queries), answers) in enumerate(data):
        length = f"({n}, {m}, {k})"
        edges.insert(0, [0,0])
        queries.insert(0, 0)
        input.append(f"result[{idx}] = ({length}, Array::new(), Array::new())")
        for u, v in edges:
            if u == 0 and v == 0:
                continue
            input.append(f"result[{idx}].1.push(({u}, {v}))")
            if len(input) > LENGTH:
                functions.append(pack_input(ipoint))
                ipoint += 1
                input = []
    
        for q in queries:
            input.append(f"result[{idx}].2.push({q})")
            if len(input) > LENGTH:
                functions.append(pack_input(ipoint))
                ipoint += 1
                input = []
        
        for a in answers:
            result.append(f"result[{idx}].push({a})")
            if len(result) > LENGTH:
                functions.append(pack_output(opoint))
                opoint += 1
                result = []
        functions.append(pack_input(ipoint))
        ipoint += 1
        functions.append(pack_output(opoint))
        opoint += 1
        input = []
        result = []

    for i in range(ipoint, ):
        input.append(f"get_data_{i}(result)")
    for i in range(opoint, ):
        result.append(f"get_answers_{i}(result)")
    output = {"data": "    \n".join(input), "answers": "    \n".join(result), "data_length": len(data), "functions": "\n".join(functions)}
    return TEMPLATE.format(**output)


def main(arg: int):
    data = reader(arg)
    output = generate(data)
    output_path = "benchmark.mbt"
    with open(output_path, "w", encoding="utf-8") as f:
        f.write(output)


if __name__ == "__main__":
    for i in range(1, 10):
        main(i)
        os.system(f"moon bench")    
    main(6)

